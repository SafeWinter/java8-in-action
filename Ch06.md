# 第 6 章 用 Stream 流收集数据 Collecting data with streams



## 0 相关代码

- 本书 GitHub：https://github.com/java8/Java8InAction/
- 本章 GitHub：https://github.com/java8/Java8InAction/tree/master/src/main/java/lambdasinaction/chap6



> **本章主要内容**

- 用 `Collectors` 类创建和使用 `Collector` 收集器
- 将数据流归约为一个值
- 汇总：归约的特殊情况
- 数据分组和分区
- 自定义 `Collector` 收集器

对交易数据集 `transactions` 按货币类型分组，函数式编程更关注 **做什么**，命令式编程更关注 **怎么做**。当汇总逻辑更加复杂时，二者优劣立见高下。

```java
// Imperative programming
Map<Currency, List<Transaction>> transactionsByCurrencies =
    new HashMap<>();
for (Transaction transaction : transactions) {
    Currency currency = transaction.getCurrency();
    List<Transaction> transactionsForCurrency =
        transactionsByCurrencies.get(currency);
    if (transactionsForCurrency == null) {
        transactionsForCurrency = new ArrayList<>();
        transactionsByCurrencies
            .put(currency, transactionsForCurrency);
    }
    transactionsForCurrency.add(transaction);
}

// Functional Programming
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream()
        .collect(groupingBy(Transaction::getCurrency));
```



## 6.1. `Collector` 收集器简介 Collectors in a nutshell

函数式 API 设计的另一大优势：易于组合与复用（higher degree of composability and reusability）。

调用 `Stream` 流的 `collect` 方法，相当于执行了一次归约操作（***reduction operation***）。

`Collector` 接口实现了常用的归约运算，如 `toList`、`toSet` 等。这些预定义的操作实现大致可分为三类：

- 归约汇总为一个单一值
- 元素分组
- 元素分野（用一个判定条件进行特殊分组）



以下案例假设都统一引入了 `Collectors` 工具类的所有静态工厂方法：

```java
import static java.util.stream.Collectors.*;
```

例如，用 `counting` 收集器计数：

```java
long howManyDishes = menu.stream().collect(Collectors.counting());
// OR
long howManyDishes = menu.stream().count();
```



## 6.2. 归约与汇总 Reducing and summarizing

利用 `maxBy` 和 `minBy` 求最大最小值：

```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
// maxBy
Optional<Dish> mostCalorieDish = menu.stream()
    .collect(maxBy(dishCaloriesComparator));
// minBy
Optional<Dish> leastCalorieDish = menu.stream()
    .collect(minBy(dishCaloriesComparator));
```

用 `summingInt` 收集器汇总菜肴热量（类似的还有 `summingLong` 和 `summingDouble`）：

```java
int totalCalories = menu.stream()
    	.collect(summingInt(Dish::getCalories));
```

用 `averagingInt` 就均值（类似还有 `averagingInt` 和 `averagingDouble`）：

```java
double avgCalories = menu.stream()
    	.collect(averagingInt(Dish::getCalories));
```

常见统计指标也可以通过 `summarizingInt` 一次性获取（同理也有 `summarizingInt` 和 `summarizingDouble`）：

```java
IntSummaryStatistics menuStatistics = menu.stream()
    	.collect(summarizingInt(Dish::getCalories));
/*
IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
*/
```



用 `joining` 工厂方法将 `Stream` 流中的元素做字符串化处理后连接在一起：

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());
```

这里默认调用的是每个元素的 `toString` 方法，串联各个字符串底层用的是 `StringBuilder`（不是线程安全的）

`joining` 添加自定义分隔符：

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
```



`reducing` 工厂方法可以描述上述各种 `Collector` 收集器方法，它是它们的一般化。例如计算总热量：

```java
// sum
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, (i, j) -> i + j));
```

其中，`reducing` 接收三个值：

- 初始值：`0`
- 转换函数：`Dish::getCalories`
- `BinaryOperator` 二元运算：`(T, T) -> T`



再如，用 `reducing` 求最大值：

```java
Optional<Dish> mostCalorieDish = menu.stream().collect(
    	reducing((d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```

这里的初始值为第一个元素，转换函数为一个 `恒等函数`（***identity function***）



> **`collect` 与 `reduce`**
>
> 考察下面一段用 `reduce` 处理的一个 `Stream` 流：
>
> ```java
> Stream<Integer> stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
> List<Integer> numbers = stream.reduce(
>     new ArrayList<Integer>(),
>     (List<Integer> l, Integer e) -> {
>         l.add(e);
>         return l; 
>     },
>     (List<Integer> l1, List<Integer> l2) -> {
>         l1.addAll(l2);
>         return l1; 
>     }
> );
> ```
>
> 上述代码是对 `reduce` 的误用。它存在两个问题：
>
> - 语义问题：本应为一个新的容器收集最终结果，现在变成直接修改原容器状态；
> - 实际问题：该过程无法进行并行运算；
>
> 为确保线程安全，每次遍历都需要分配一个新的 `List` 容器，但分配新容器又会带来性能损耗。而 `Collector` 很好地处理了变更容器的问题，也支持并行操作。



求和也可以使用 `Integer::sum`：

```java
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, Integer::sum));
```

注意到第二参数可以是任意转换函数，因此计数操作也可以用 `reduce` 写为：

```java
int dishCount = menu.stream().collect(
    	reducing(0, e -> 1L, Long::sum));
```

等效为：

```java
public static <T> Collector<T, ?, Long> counting() {
    return reducing(0L, e -> 1L, Long::sum);
}
```

注意，`counting` 方法的返回值的类型中，`T` 表示集合元素的类型，`?` 表示累加器的类型（未知，即任意），`Long` 则为最后结果的类型。



求和写法汇总：

```java
// Solution 1
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, (i, j) -> i + j));
// Solution 2
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, Integer::sum);
// Solution 3
int totalCalories = menu.stream()
    	.map(Dish::getCalories)
    	.reduce(Integer::sum)
    	.get();
// Solution 4
int totalCalories = menu.stream()
    	.mapToInt(Dish::getCalories)
    	.sum();
```

注意第三种解法，`menu` 流通过 `map` 映射为数字后，执行 `reduce` 的返回值是 `Optional<Integer>`，以避免 `Stream` 流为空的情况。

可见函数式编程的一大特点：同一问题通常有多种实现方式。应视情况选择最佳方案。本例选择方案4，直观且避免频繁装箱拆箱。



## 6.3. 分组 Grouping

按 `type` 属性对 `menu` 集合分组，可以使用 `Collectors` 的工厂方法 `groupingBy`：

```java
Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
    	.collect(groupingBy(Dish::getType));
/* dishesByType: {
  FISH=[prawns, salmon], 
  OTHER=[french fries, rice, season fruit, pizza],
  MEAT=[pork, beef, chicken]
}*/
```

如果直接引用 `getter` 方法不满足分组需求，则可以自定义一个分组标准（即热量级别 `CaloricLevel`）：

```java
public enum CaloricLevel { DIET, NORMAL, FAT }
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel = menu.stream().collect(
        groupingBy(dish -> {
            if (dish.getCalories() <= 400) 
                return CaloricLevel.DIET;
            else if (dish.getCalories() <= 700) 
                return CaloricLevel.NORMAL;
            else 
                return CaloricLevel.FAT;
        }));
```



### 6.3.1. 多级分组（Multilevel grouping）

先按菜肴类别（`Dish.type`）、再按热量级别（`CaloricLevel`）分类，可在 `groupingBy` 中再次使用 `groupingBy`：

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel =
        menu.stream().collect(
                groupingBy(Dish::getType,
                        groupingBy(dish -> {
                            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                            else return CaloricLevel.FAT;
                        })
                )
        );
/*{
  MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]},
  FISH={DIET=[prawns], NORMAL=[salmon]},
  OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}
}*/
```



### 6.3.2. 按子分组收集数据（Collecting data in subgroups）

既然 `groupingBy` 收集器可以作外层 `groupingBy` 的第二参数，其他 `Collector` 收集器也可以，比如计数方法 `counting`：

```java
Map<Dish.Type, Long> typesCount = menu.stream()
    	.collect(groupingBy(Dish::getType, counting()));
/*{MEAT=3, FISH=2, OTHER=4}*/
```

再如极大值方法 `maxBy`：

```java
Map<Dish.Type, Optional<Dish>> mostCaloricByType = menu.stream()
        .collect(groupingBy(Dish::getType,
                maxBy(comparingInt(Dish::getCalories))));
```

注意，`groupingBy` 也有单个参数的写法：`groupingBy(fn)`，这里的 `fn` 即分类函数，效果上等效于：`groupingBy(f, toList())`。

由于使用了 `maxBy`，返回值的类型也变成了 `Optional<Dish>`，但事实上 `groupingBy` 对不存在的分组，不会映射一个 `Optional.empty()` 值；反之，只有确实满足分组条件的元素，才会在结果中声明一个确定的 `Key`，因此这里的 `Optional` 有点多余，因为 `Optional` 类型仅仅是因为引用了 `maxBy` 这一操作。为了解决这一问题，需要使用 `collectingAndThen`，在原来的 `maxBy` 后面再跟一个映射函数（`Optional::get`）进行转换：

```java
Map<Dish.Type, Dish> mostCaloricByType = menu.stream()
        .collect(groupingBy(Dish::getType,
                collectingAndThen(
                        maxBy(comparingInt(Dish::getCalories)),
                        Optional::get
                )
        ));
/*{FISH=salmon, OTHER=pizza, MEAT=pork}*/
```



分组后，各组映射的值，除了是元素本身外，也可以是其他值。比如对各组元素的热量求和（`summingInt(getter)`）：

```java
Map<Dish.Type, Integer> totalCaloriesByType = menu.stream().collect(
        groupingBy(Dish::getType, summingInt(Dish::getCalories)));
```

也可以按自定义的标准（`CaloricLevel`），实现自定义的收集方式，不仅仅是默认的 `List`：

```java
Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByType =
        menu.stream().collect(
                groupingBy(Dish::getType, mapping(
                        dish -> { 
                            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                            else return CaloricLevel.FAT; 
                        },
                        toSet()
                ))
        );
/*{OTHER=[DIET, NORMAL], MEAT=[DIET, NORMAL, FAT], FISH=[DIET, NORMAL]}*/
```

注意：第 9 行指定了分组后的数据收集方式：按集合收集，以实现无重复分类。但具体是什么 `Set` 并不确定，如果需要指定以 `HashSet` 进行收集，可以写作：

```java
Map<Dish.Type, Set<CaloricLevel>> caloricLevelsByType =
        menu.stream().collect(
                groupingBy(Dish::getType, mapping(
                        dish -> { 
                            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                            else return CaloricLevel.FAT; 
                        },
                        toCollection(HashSet::new)
                ))
        );
```





## 6.4. 分区 Partitioning





## 6.5. `Collector` 收集器接口 The Collector interface





## 6.6. 开发自己的 `Collector` 收集器以获得更好的性能 Developing your own collector for better performance





## 6.7. 小结



