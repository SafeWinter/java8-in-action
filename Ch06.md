# 第 6 章 用 Stream 流收集数据 Collecting data with streams



## 0 相关代码

- 本书 GitHub：https://github.com/java8/Java8InAction/
- 本章 GitHub：https://github.com/java8/Java8InAction/tree/master/src/main/java/lambdasinaction/chap6



> **本章主要内容**

- 用 `Collectors` 类创建和使用 `Collector` 收集器
- 将数据流归约为一个值
- 汇总：归约的特殊情况
- 数据分组和分区
- 自定义 `Collector` 收集器

对交易数据集 `transactions` 按货币类型分组，函数式编程更关注 **做什么**，命令式编程更关注 **怎么做**。当汇总逻辑更加复杂时，二者优劣立见高下。

```java
// Imperative programming
Map<Currency, List<Transaction>> transactionsByCurrencies =
    new HashMap<>();
for (Transaction transaction : transactions) {
    Currency currency = transaction.getCurrency();
    List<Transaction> transactionsForCurrency =
        transactionsByCurrencies.get(currency);
    if (transactionsForCurrency == null) {
        transactionsForCurrency = new ArrayList<>();
        transactionsByCurrencies
            .put(currency, transactionsForCurrency);
    }
    transactionsForCurrency.add(transaction);
}

// Functional Programming
Map<Currency, List<Transaction>> transactionsByCurrencies = transactions.stream()
        .collect(groupingBy(Transaction::getCurrency));
```



## 6.1. `Collector` 收集器简介 Collectors in a nutshell

函数式 API 设计的另一大优势：易于组合与复用（higher degree of composability and reusability）。

调用 `Stream` 流的 `collect` 方法，相当于执行了一次归约操作（***reduction operation***）。

`Collector` 接口实现了常用的归约运算，如 `toList`、`toSet` 等。这些预定义的操作实现大致可分为三类：

- 归约汇总为一个单一值
- 元素分组
- 元素分割（用一个判定条件进行特殊分组）



以下案例假设都统一引入了 `Collectors` 工具类的所有静态工厂方法：

```java
import static java.util.stream.Collectors.*;
```

例如，用 `counting` 收集器计数：

```java
long howManyDishes = menu.stream().collect(Collectors.counting());
// OR
long howManyDishes = menu.stream().count();
```



## 6.2. 归约与汇总 Reducing and summarizing

利用 `maxBy` 和 `minBy` 求最大最小值：

```java
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
// maxBy
Optional<Dish> mostCalorieDish = menu.stream()
    .collect(maxBy(dishCaloriesComparator));
// minBy
Optional<Dish> leastCalorieDish = menu.stream()
    .collect(minBy(dishCaloriesComparator));
```

用 `summingInt` 收集器汇总菜肴热量（类似的还有 `summingLong` 和 `summingDouble`）：

```java
int totalCalories = menu.stream()
    	.collect(summingInt(Dish::getCalories));
```

用 `averagingInt` 就均值（类似还有 `averagingInt` 和 `averagingDouble`）：

```java
double avgCalories = menu.stream()
    	.collect(averagingInt(Dish::getCalories));
```

常见统计指标也可以通过 `summarizingInt` 一次性获取（同理也有 `summarizingInt` 和 `summarizingDouble`）：

```java
IntSummaryStatistics menuStatistics = menu.stream()
    	.collect(summarizingInt(Dish::getCalories));
/*
IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
*/
```



用 `joining` 工厂方法将 `Stream` 流中的元素做字符串化处理后连接在一起：

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining());
```

这里默认调用的是每个元素的 `toString` 方法，串联各个字符串底层用的是 `StringBuilder`（不是线程安全的）

`joining` 添加自定义分隔符：

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
```



`reducing` 工厂方法可以描述上述各种 `Collector` 收集器方法，它是它们的一般化。例如计算总热量：

```java
// sum
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, (i, j) -> i + j));
```

其中，`reducing` 接收三个值：

- 初始值：`0`
- 转换函数：`Dish::getCalories`
- `BinaryOperator` 二元运算：`(T, T) -> T`



再如，用 `reducing` 求最大值：

```java
Optional<Dish> mostCalorieDish = menu.stream().collect(
    	reducing((d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```

这里的初始值为第一个元素，转换函数为一个 `恒等函数`（***identity function***）



> **`collect` 与 `reduce`**
>
> 考察下面一段用 `reduce` 处理的一个 `Stream` 流：
>
> ```java
> Stream<Integer> stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
> List<Integer> numbers = stream.reduce(
>     new ArrayList<Integer>(),
>     (List<Integer> l, Integer e) -> {
>         l.add(e);
>         return l; 
>     },
>     (List<Integer> l1, List<Integer> l2) -> {
>         l1.addAll(l2);
>         return l1; 
>     }
> );
> ```
>
> 上述代码是对 `reduce` 的误用。它存在两个问题：
>
> - 语义问题：本应为一个新的容器收集最终结果，现在变成直接修改原容器状态；
> - 实际问题：该过程无法进行并行运算；
>
> 为确保线程安全，每次遍历都需要分配一个新的 `List` 容器，但分配新容器又会带来性能损耗。而 `Collector` 很好地处理了变更容器的问题，也支持并行操作。



求和也可以使用 `Integer::sum`：

```java
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, Integer::sum));
```

注意到第二参数可以是任意转换函数，因此计数操作也可以用 `reduce` 写为：

```java
int dishCount = menu.stream().collect(
    	reducing(0, e -> 1L, Long::sum));
```

等效为：

```java
public static <T> Collector<T, ?, Long> counting() {
    return reducing(0L, e -> 1L, Long::sum);
}
```

注意，`counting` 方法的返回值的类型中，`T` 表示集合元素的类型，`?` 表示累加器的类型（未知，即任意），`Long` 则为最后结果的类型。



求和写法汇总：

```java
// Solution 1
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, (i, j) -> i + j));
// Solution 2
int totalCalories = menu.stream().collect(
    	reducing(0, Dish::getCalories, Integer::sum);
// Solution 3
int totalCalories = menu.stream()
    	.map(Dish::getCalories)
    	.reduce(Integer::sum)
    	.get();
// Solution 4
int totalCalories = menu.stream()
    	.mapToInt(Dish::getCalories)
    	.sum();
```

可见函数式编程的一大特点：同一问题通常有多种实现方式。应视情况选择最佳方案。本例选择方案4，直观且避免频繁装箱拆箱。



## 6.3. 分组 Grouping





## 6.4. 分区 Partitioning





## 6.5. `Collector` 收集器接口 The Collector interface





## 6.6. 开发自己的 `Collector` 收集器以获得更好的性能 Developing your own collector for better performance





## 6.7. 小结



